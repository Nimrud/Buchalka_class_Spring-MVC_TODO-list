1) CHALLENGE 1 (project setup)
    1) add dependencies for the following artifacts:
        => spring-webmvc
        => lombok
        => logback-classic
        => javax.annotation-api
    2) setup the maven-compiler plugin like in Spring_Guess-the-number-game project
        (w obecne wersji już niepotrzebne - Maven jest już zainstalowany)
        kod:
            <build>
                <plugins>
                    <plugin>
                        <groupId>org.apache.maven.plugins</groupId>
                        <artifactId>maven-compiler-plugin</artifactId>
                        <version>${maven.version}</version>
                        <configuration>
                            <target>${java.version}</target>
                            <source>${java.version}</source>
                            <release>${java.version}</release>
                        </configuration>
                    </plugin>
                </plugins>
            </build>
    3) add logback.xml file from the before mentioned project
    4) execute Maven goals clean and install after setting up all dependencies
    tip: use Maven properties whenever you can
2) Dodanie pluginu Maven WAR (Web Application Archive)
    1) dodanie paczki WAR do projektu:
        -> w pliku pom.xml dodanie tagu <packaging>war</packaging>
        -> dodajemy najnowszą wersję pluginu w tym pliku:
                <build>
                    <plugins>
                        <plugin>
                            <groupId>org.apache.maven.plugins</groupId>
                            <artifactId>maven-war-plugin</artifactId>
                            <version>3.3.1</version>
                            <configuration>
                                <failOnMissingWebXml>false</failOnMissingWebXml>
                            </configuration>
                        </plugin>
                    </plugins>
                </build>
           WAŻNE: bez części <configuration> kompilacja się nie powiedzie (brak pliku 'web.xml')
           ...albo to samo, ale w wersji <dependency>
    2) w folderze 'main' (w src) tworzymy nowy folder 'webapp'
        (w nim znajdą się pliki takie jak .css czy .js)
    3) w powyższym folderze tworzymy folder 'WEB-INF'
        (w nim zazwyczaj umieszczamy pliki .jsp, konfiguracyjne, szablony itp., czyli pliki,
         które nie są bezpośrednio udostępniane na zewnątrz, ale są widoczne dla serwletów)
    4) w folderze 'webapp' tworzymy stronę główną (np. 'index.html')
3) Dodanie pluginu Maven Cargo (ten plugin uruchamia serwer Tomcat)
    -> w pliku 'pom.xml', w sekcji plugins dodajemy
        <plugin>
            <groupId>org.codehaus.cargo</groupId>
            <artifactId>cargo-maven3-plugin</artifactId>
            <version>1.9.6</version>
            <configuration>
                <container>
                    <containerId>tomcat9x</containerId>
                    <type>embedded</type>
                </container>
            </configuration>
        </plugin>
    -> Maven -> reload all -> execute Maven goal -> mvn clean install
    -> Maven -> [project] -> Plugins -> cargo -> cargo:run
    -> odpalamy przeglądarkę (http://localhost:8080/[projekt]/index.html)
    UWAGA! Wpisy Loggera się nie wyświetlają w konsoli, jeśli używamy Tomcata 10 (działają dla wersji 9x)
4) Tworzenie Dispatcher Servletu (dyspozytora)
    -> tworzymy folder 'config' w folderze 'java', a nim klasę WebConfig
        (musi być oznaczona adnotacją @EnableWebMvc)
    -> dodajemy dependency serwletu w pliku pom.xml (MVN Repo: Java Servlet API)
    -> rejestracja serwletu: implementujemy interfejs WebApplicationInitializer
        => tworzymy klasę WebAppInitializer (z powyższą implementacją)
        => implementujemy metodę onStartup
        => w niej tworzymy kontekst aplikacji (=Spring Container)
            oraz, używając tego kontekstu, rejestrujemy aplikację webową
            (uwaga: aby zarejestrować klasę, musi ona zostać oznaczona @Configuration)
        => tworzymy Dispatcher Servlet oraz rejestrujemy go używając servletContext
            (który jest parametrem metody onStartup)
            nadajemy też naszemu serwletowi nazwę
            używamy metod setLoadOnStartup (kontekst stworzy instancję serwletu i ją zainicjalizuje)
                oraz addMapping (nadanie serwletowi adresu URL)
    -> sprawdzamy, czy działa (Maven -> mvn clean install; Maven -> Plugins -> Cargo -> run)
5) TIP: jeśli po zmianie kodu chcemy szybko zrobić mvn clean, install oraz cargo:run,
    to klikamy prawym przyciskiem na cargo:run, wybieramy ModifyRun Configuration,
    a w nim zamieniamy:  cargo:run -f pom.xml
    na:  clean install cargo:run -f pom.xml
    Pojawi się nowa opcja w okienku Maven (Run Configurations)
6) Tworzenie pierwszego kontrolera
    [pakiet] -> nowy folder 'controller' -> nowa klasa 'Controller' (@Controller)
    w niej tworzymy metodę z adnotacjami
    @GetMapping  => w nawiasie podajemy końcówkę adresu URL, pod którym jest ona dostępna
    @ResponseBody  => jeśli chcemy zwrócić wpisany tekst do przeglądarki (zamiast widoku)
7) View Resolver oraz View
    1) folder webapp -> WEB-INF -> nowy folder 'view' -> nowy plik widoku (.jsp)
    2) w klasie WebConfig dodajemy Bean method 'viewResolver'
        doda ona do każdego widoku początek ścieżki oraz rozszerzenie .jsp
        (czyli każdemu widokowi będziemy nadawać samą nazwę)
    3) w klasie DemoController dodajemy nową metodę
        dodajemy @GetMapping oraz nazwę widoku (jako 'return')
8) Model
    przechowuje dane w formacie 'kucz - wartość'
    można dodawać dane na 2 sposoby:
        -> model.addAttribute("klucz", "wartość")
            do wartości można się odwoływać w pliku .jsp => ${klucz}
        -> za pomocą adnotacji @ModelAttribute("wartość")
            do wartości w nawiasie można się odwoływać w pliku .jsp => ${wartość}
9) CHALLENGE 2 (service)
    1) create an interface called DemoService with a method named getHelloMessage()
        that has a String parameter called user and create another method named
        getWelcomeMessage() without parameters - both methods should return a String
    2) create a class called DemoServiceImpl and annotate it with the @Service annotation
    3) the DemoServiceImpl class needs to implement the interface, and within the class,
        the method getHelloMessage() should return the String "Hello " + user,
        and the method getWelcomeMessage() should return the String
        "Welcome to this Demo Application"
    4) in DemoController inject/autowire DemoService using constructor injection
    5) in the controller methods, use DemoService to add attributes to the model
        instead of using Strings. In other words, call the service methods
        to get messages that are used as model attributes and displayed by JSP page
    6) you have to remove the user model attribute in the welcome() controller method
        and use another attribute instead (the value for the attribute should come
        from calling getHelloMessage() from DemoService
    7) modify the welcome.jsp file to use the new model attribute name instead of user
10)



