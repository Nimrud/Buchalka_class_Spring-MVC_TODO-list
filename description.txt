1) CHALLENGE 1 (project setup)
    1) add dependencies for the following artifacts:
        => spring-webmvc
        => lombok
        => logback-classic
        => javax.annotation-api
    2) setup the maven-compiler plugin like in Spring_Guess-the-number-game project
        (w obecne wersji już niepotrzebne - Maven jest już zainstalowany)
        kod:
            <build>
                <plugins>
                    <plugin>
                        <groupId>org.apache.maven.plugins</groupId>
                        <artifactId>maven-compiler-plugin</artifactId>
                        <version>${maven.version}</version>
                        <configuration>
                            <target>${java.version}</target>
                            <source>${java.version}</source>
                            <release>${java.version}</release>
                        </configuration>
                    </plugin>
                </plugins>
            </build>
    3) add logback.xml file from the before mentioned project
    4) execute Maven goals clean and install after setting up all dependencies
    tip: use Maven properties whenever you can
2) Dodanie pluginu Maven WAR (Web Application Archive)
    1) dodanie paczki WAR do projektu:
        -> w pliku pom.xml dodanie tagu <packaging>war</packaging>
        -> dodajemy najnowszą wersję pluginu w tym pliku:
                <build>
                    <plugins>
                        <plugin>
                            <groupId>org.apache.maven.plugins</groupId>
                            <artifactId>maven-war-plugin</artifactId>
                            <version>3.3.1</version>
                            <configuration>
                                <failOnMissingWebXml>false</failOnMissingWebXml>
                            </configuration>
                        </plugin>
                    </plugins>
                </build>
           WAŻNE: bez części <configuration> kompilacja się nie powiedzie (brak pliku 'web.xml')
           ...albo to samo, ale w wersji <dependency>
    2) w folderze 'main' (w src) tworzymy nowy folder 'webapp'
        (w nim znajdą się pliki takie jak .css czy .js)
    3) w powyższym folderze tworzymy folder 'WEB-INF'
        (w nim zazwyczaj umieszczamy pliki .jsp, konfiguracyjne, szablony itp., czyli pliki,
         które nie są bezpośrednio udostępniane na zewnątrz, ale są widoczne dla serwletów)
    4) w folderze 'webapp' tworzymy stronę główną (np. 'index.html')
3) Dodanie pluginu Maven Cargo (ten plugin uruchamia serwer Tomcat)
    -> w pliku 'pom.xml', w sekcji plugins dodajemy
        <plugin>
            <groupId>org.codehaus.cargo</groupId>
            <artifactId>cargo-maven3-plugin</artifactId>
            <version>1.9.6</version>
            <configuration>
                <container>
                    <containerId>tomcat9x</containerId>
                    <type>embedded</type>
                </container>
            </configuration>
        </plugin>
    -> Maven -> reload all -> execute Maven goal -> mvn clean install
    -> Maven -> [project] -> Plugins -> cargo -> cargo:run
    -> odpalamy przeglądarkę (http://localhost:8080/[projekt]/index.html)
    UWAGA! Wpisy Loggera się nie wyświetlają w konsoli, jeśli używamy Tomcata 10 (działają dla wersji 9x)
4) Tworzenie Dispatcher Servletu (dyspozytora)
    -> tworzymy folder 'config' w folderze 'java', a nim klasę WebConfig
        (musi być oznaczona adnotacją @EnableWebMvc)
    -> dodajemy dependency serwletu w pliku pom.xml (MVN Repo: Java Servlet API)
    -> rejestracja serwletu: implementujemy interfejs WebApplicationInitializer
        => tworzymy klasę WebAppInitializer (z powyższą implementacją)
        => implementujemy metodę onStartup
        => w niej tworzymy kontekst aplikacji (=Spring Container)
            oraz, używając tego kontekstu, rejestrujemy aplikację webową
            (uwaga: aby zarejestrować klasę, musi ona zostać oznaczona @Configuration)
        => tworzymy Dispatcher Servlet oraz rejestrujemy go używając servletContext
            (który jest parametrem metody onStartup)
            nadajemy też naszemu serwletowi nazwę
            używamy metod setLoadOnStartup (kontekst stworzy instancję serwletu i ją zainicjalizuje)
                oraz addMapping (nadanie serwletowi adresu URL)
    -> sprawdzamy, czy działa (Maven -> mvn clean install; Maven -> Plugins -> Cargo -> run)
5) TIP: jeśli po zmianie kodu chcemy szybko zrobić mvn clean, install oraz cargo:run,
    to klikamy prawym przyciskiem na cargo:run, wybieramy ModifyRun Configuration,
    a w nim zamieniamy:  cargo:run -f pom.xml
    na:  clean install cargo:run -f pom.xml
    Pojawi się nowa opcja w okienku Maven (Run Configurations)
6) Tworzenie pierwszego kontrolera
    [pakiet] -> nowy folder 'controller' -> nowa klasa 'Controller' (@Controller)
    w niej tworzymy metodę z adnotacjami
    @GetMapping  => w nawiasie podajemy końcówkę adresu URL, pod którym jest ona dostępna
    @ResponseBody  => jeśli chcemy zwrócić wpisany tekst do przeglądarki (zamiast widoku)
7) View Resolver oraz View
    1) folder webapp -> WEB-INF -> nowy folder 'view' -> nowy plik widoku (.jsp)
    2) w klasie WebConfig dodajemy Bean method 'viewResolver'
        doda ona do każdego widoku początek ścieżki oraz rozszerzenie .jsp
        (czyli każdemu widokowi będziemy nadawać samą nazwę)
    3) w klasie DemoController dodajemy nową metodę
        dodajemy @GetMapping oraz nazwę widoku (jako 'return')
8) Model
    przechowuje dane w formacie 'kucz - wartość'
    można dodawać dane na 2 sposoby:
        -> model.addAttribute("klucz", "wartość")
        -> za pomocą adnotacji @ModelAttribute



